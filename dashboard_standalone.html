<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airline Tech Ops SPC Dashboard</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #111827;
            color: #e5e7eb;
        }
        .header {
            background: #1f2937;
            padding: 1rem 2rem;
            border-bottom: 1px solid #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }
        .header h1 {
            color: #06b6d4;
            font-size: 1.5rem;
        }
        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }
        button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #4f46e5;
            color: white;
        }
        .btn-primary:hover { background: #4338ca; }
        .btn-secondary {
            background: #374151;
            color: #e5e7eb;
        }
        .btn-secondary:hover { background: #4b5563; }
        input[type="text"], select {
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #374151;
            background: #374151;
            color: #e5e7eb;
        }
        .main {
            padding: 2rem;
        }
        .station-section {
            margin-bottom: 3rem;
        }
        .station-title {
            color: #06b6d4;
            font-size: 2rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #06b6d4;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 2rem;
        }
        .chart-container {
            background: #1f2937;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            border: 1px solid #374151;
        }
        .chart-header {
            background: #374151;
            margin: -1rem -1rem 0.75rem -1rem;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem 0.5rem 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chart-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: #e5e7eb;
        }
        .chart-subtitle {
            font-size: 0.875rem;
            color: #9ca3af;
            margin-top: 0.25rem;
        }
        .chart-stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.875rem;
            color: #d1d5db;
        }
        .chart-stat {
            display: flex;
            flex-direction: column;
        }
        .chart-stat-label {
            color: #9ca3af;
            font-size: 0.75rem;
        }
        .chart-stat-value {
            font-weight: 700;
            font-size: 1rem;
            color: #06b6d4;
        }
        .chart-canvas {
            width: 100%;
            height: 350px;
            background: #0f172a;
            border-radius: 0.25rem;
            border: 1px solid #1e293b;
            cursor: crosshair;
        }
        .chart-wrapper {
            position: relative;
        }
        .tooltip {
            position: absolute;
            background: rgba(31, 41, 55, 0.98);
            border: 2px solid #4f46e5;
            border-radius: 0.5rem;
            padding: 0.75rem;
            pointer-events: none;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            min-width: 220px;
        }
        .tooltip-date {
            font-weight: 700;
            color: #06b6d4;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            border-bottom: 1px solid #374151;
            padding-bottom: 0.25rem;
        }
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 0.25rem 0;
            font-size: 0.875rem;
        }
        .tooltip-label {
            color: #9ca3af;
            margin-right: 1rem;
        }
        .tooltip-value {
            font-weight: 700;
            color: #e5e7eb;
        }
        .tooltip-value.out-of-control {
            color: #f87171;
        }
        .tooltip-value.in-control {
            color: #4ade80;
        }
        .loading {
            text-align: center;
            padding: 4rem;
            font-size: 1.5rem;
            color: #60a5fa;
        }
        .error {
            text-align: center;
            padding: 2rem;
            background: #7f1d1d;
            border: 1px solid: #991b1b;
            border-radius: 0.5rem;
            color: #fca5a5;
        }
        .message {
            text-align: center;
            padding: 2rem;
            background: #1f2937;
            border-radius: 0.5rem;
            color: #9ca3af;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 1rem;
            font-size: 0.875rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .legend-line {
            width: 30px;
            height: 3px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Airline Tech Ops SPC Dashboard</h1>
        <div class="controls">
            <button class="btn-primary" onclick="loadActualData()" style="background: #059669; font-size: 1.1rem; padding: 0.625rem 1.25rem;">📊 Load Test Data</button>
            <input type="file" id="csvFile" accept=".csv" style="display:none" onchange="handleFileUpload(event)">
            <button class="btn-secondary" onclick="document.getElementById('csvFile').click()">📤 Upload CSV (Auto-Detect Format)</button>
            <input type="text" id="newStation" placeholder="Add Station (e.g., SFO)" style="width: 160px">
            <button class="btn-secondary" onclick="addStation()">Add</button>
            <select id="stationSelect" onchange="filterStation()">
                <option value="all">All Stations</option>
            </select>
        </div>
    </div>
    
    <div class="main">
        <div id="content">
            <div class="message">
                <p style="font-size: 1.5rem; margin-bottom: 1rem;">📊 Ready to View SPC Charts</p>
                <p style="font-size: 1.125rem; color: #9ca3af;">Click <strong style="color: #059669;">"Load Test Data"</strong> above to view:</p>
                <ul style="list-style: none; padding: 0; margin-top: 1rem; font-size: 1rem; color: #d1d5db;">
                    <li>✓ Austin (AUS)</li>
                    <li>✓ Dallas Love Field (DAL)</li>
                    <li>✓ Houston Hobby (HOU)</li>
                </ul>
                <p style="margin-top: 1rem; font-size: 0.875rem; color: #6b7280;">Simulated test data • January 2023 to present • 4 maintenance metrics</p>
                <p style="margin-top: 0.5rem; font-size: 0.75rem; color: #6b7280;">Upload supports: timestamp,station,metric_value (filename = measure) OR station,measure,date,value</p>
            </div>
        </div>
    </div>

    <script>
        let allData = null;
        let chartData = null;
        let currentFilter = 'all';

        async function loadActualData() {
            document.getElementById('content').innerHTML = '<div class="loading">Loading Test Data...</div>';
            
            try {
                const response = await fetch('http://localhost:8000/api/load-actual', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    chartData = result.chartData;
                    updateStationSelect(result.stations);
                    renderCharts();
                } else {
                    showError(result.error || 'Failed to load test data');
                }
            } catch (err) {
                showError('Failed to connect to server. Make sure server.py is running.');
            }
        }

        async function loadDemoData() {
            document.getElementById('content').innerHTML = '<div class="loading">Processing Data...</div>';
            
            try {
                const response = await fetch('http://localhost:8000/api/demo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    chartData = result.chartData;
                    updateStationSelect(result.stations);
                    renderCharts();
                } else {
                    showError(result.error || 'Failed to process data');
                }
            } catch (err) {
                showError('Failed to connect to server. Make sure server.py is running.');
            }
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('content').innerHTML = '<div class="loading">Processing ' + file.name + '...</div>';
            
            try {
                const text = await file.text();
                const response = await fetch('http://localhost:8000/api/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        csvData: text,
                        filename: file.name
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    chartData = result.chartData;
                    updateStationSelect(result.stations);
                    renderCharts();
                } else {
                    showError(`Upload Failed: ${result.error || 'Invalid CSV format'}<br><br>
                        <strong>Supported formats:</strong><br>
                        1. timestamp,station,metric_value (filename used as measure)<br>
                        2. station,measure,date,value<br><br>
                        Your file appears to have a different format.`);
                }
            } catch (err) {
                showError('Failed to process CSV file: ' + err.message);
            }
        }

        function updateStationSelect(stations) {
            const select = document.getElementById('stationSelect');
            select.innerHTML = '<option value="all">All Stations</option>';
            stations.forEach(station => {
                const option = document.createElement('option');
                option.value = station;
                option.textContent = station;
                select.appendChild(option);
            });
        }

        function filterStation() {
            currentFilter = document.getElementById('stationSelect').value;
            renderCharts();
        }

        function addStation() {
            const input = document.getElementById('newStation');
            const station = input.value.trim().toUpperCase();
            if (station) {
                const select = document.getElementById('stationSelect');
                const exists = Array.from(select.options).some(opt => opt.value === station);
                if (!exists) {
                    const option = document.createElement('option');
                    option.value = station;
                    option.textContent = station;
                    select.appendChild(option);
                }
                input.value = '';
            }
        }

        function renderCharts() {
            if (!chartData) return;
            
            const stations = currentFilter === 'all' 
                ? Object.keys(chartData) 
                : [currentFilter];
            
            let html = '';
            
            stations.forEach(station => {
                if (!chartData[station]) return;
                
                html += `<div class="station-section">`;
                html += `<h2 class="station-title">${station}</h2>`;
                html += `<div class="charts-grid">`;
                
                const measures = Object.keys(chartData[station]);
                measures.forEach(measure => {
                    const data = chartData[station][measure];
                    const canvasId = `chart-${station}-${measure}`.replace(/[^a-zA-Z0-9]/g, '-');
                    
                    // Calculate statistics
                    const points = data.points || [];
                    const mean = points.length > 0 ? (points.reduce((sum, p) => sum + p.value, 0) / points.length).toFixed(2) : 'N/A';
                    const ucl = points.length > 0 && points[0].ucl ? points[0].ucl.toFixed(2) : 'N/A';
                    const lcl = points.length > 0 && points[0].lcl ? points[0].lcl.toFixed(2) : 'N/A';
                    const dateRange = points.length > 0 ? `${new Date(points[0].date).toLocaleDateString()} - ${new Date(points[points.length-1].date).toLocaleDateString()}` : '';
                    
                    html += `
                        <div class="chart-container" id="container-${canvasId}">
                            <div class="chart-header">
                                <div>
                                    <div class="chart-title">${measure}</div>
                                    <div class="chart-subtitle">${station} • ${dateRange}</div>
                                </div>
                                <div class="chart-stats">
                                    <div class="chart-stat">
                                        <span class="chart-stat-label">Mean</span>
                                        <span class="chart-stat-value">${mean}</span>
                                    </div>
                                    <div class="chart-stat">
                                        <span class="chart-stat-label">UCL</span>
                                        <span class="chart-stat-value">${ucl}</span>
                                    </div>
                                    <div class="chart-stat">
                                        <span class="chart-stat-label">LCL</span>
                                        <span class="chart-stat-value">${lcl}</span>
                                    </div>
                                    <button onclick="downloadChartWithHeader('container-${canvasId}', '${station}_${measure}')" 
                                            style="padding: 0.4rem 0.75rem; background: #4f46e5; color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; margin-left: 0.5rem;">
                                        💾 Save PNG
                                    </button>
                                </div>
                            </div>
                            <div class="chart-wrapper">
                                <canvas id="${canvasId}" class="chart-canvas"></canvas>
                                <div id="tooltip-${canvasId}" class="tooltip"></div>
                            </div>
                            <div class="legend">
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #38bdf8;"></div>
                                    <span>Value</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #4ade80;"></div>
                                    <span>CL</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-line" style="background: #fb923c; opacity: 0.7;"></div>
                                    <span>UCL/LCL</span>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `</div></div>`;
            });
            
            document.getElementById('content').innerHTML = html;
            
            // Draw all charts with interactive tooltips
            stations.forEach(station => {
                if (!chartData[station]) return;
                const measures = Object.keys(chartData[station]);
                measures.forEach(measure => {
                    const canvasId = `chart-${station}-${measure}`.replace(/[^a-zA-Z0-9]/g, '-');
                    const canvas = document.getElementById(canvasId);
                    const tooltip = document.getElementById(`tooltip-${canvasId}`);
                    if (canvas && tooltip) {
                        const data = chartData[station][measure];
                        drawChart(canvas, data);
                        setupInteractivity(canvas, tooltip, data);
                    }
                });
            });
        }

        function setupInteractivity(canvas, tooltip, data) {
            const rect = canvas.getBoundingClientRect();
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const plotWidth = rect.width - padding.left - padding.right;
            
            canvas.addEventListener('mousemove', (e) => {
                const mouseX = e.offsetX;
                const mouseY = e.offsetY;
                
                // Check if mouse is in plot area
                if (mouseX < padding.left || mouseX > rect.width - padding.right ||
                    mouseY < padding.top || mouseY > rect.height - padding.bottom) {
                    tooltip.style.display = 'none';
                    return;
                }
                
                // Find nearest data point
                const points = data.points;
                const xScale = plotWidth / (points.length - 1);
                const index = Math.round((mouseX - padding.left) / xScale);
                
                if (index >= 0 && index < points.length) {
                    const point = points[index];
                    const outOfControl = point.value > point.ucl || point.value < point.lcl;
                    const dateStr = new Date(point.date).toLocaleDateString('en-US', { 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric' 
                    });
                    
                    tooltip.innerHTML = `
                        <div class="tooltip-date">${dateStr}</div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Value:</span>
                            <span class="tooltip-value ${outOfControl ? 'out-of-control' : 'in-control'}">${point.value.toFixed(2)}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">UCL:</span>
                            <span class="tooltip-value">${point.ucl.toFixed(2)}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">CL:</span>
                            <span class="tooltip-value">${point.cl.toFixed(2)}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">LCL:</span>
                            <span class="tooltip-value">${point.lcl.toFixed(2)}</span>
                        </div>
                        ${outOfControl ? '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #374151; color: #f87171; font-size: 0.75rem; font-weight: 700;">⚠️ OUT OF CONTROL</div>' : ''}
                    `;
                    
                    // Position tooltip
                    const tooltipX = Math.min(e.offsetX + 15, rect.width - 240);
                    const tooltipY = Math.max(e.offsetY - 100, 10);
                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                    tooltip.style.display = 'block';
                    
                    // Highlight point
                    drawChart(canvas, data, index);
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
                drawChart(canvas, data);
            });
        }

        function drawChart(canvas, data, highlightIndex = null) {
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;
            
            const points = data.points;
            if (!points || points.length === 0) return;
            
            // Get value range
            const values = points.map(p => p.value);
            const ucls = points.map(p => p.ucl).filter(v => v != null);
            const lcls = points.map(p => p.lcl).filter(v => v != null);
            const allValues = [...values, ...ucls, ...lcls];
            const minValue = Math.min(...allValues) * 0.95;
            const maxValue = Math.max(...allValues) * 1.05;
            
            // Helper functions
            const xScale = (index) => padding.left + (index / (points.length - 1)) * plotWidth;
            const yScale = (value) => padding.top + plotHeight - ((value - minValue) / (maxValue - minValue)) * plotHeight;
            
            // Clear canvas
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid lines
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (i / 5) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
                
                // Y-axis labels
                const value = maxValue - (i / 5) * (maxValue - minValue);
                ctx.fillStyle = '#9ca3af';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(1), padding.left - 10, y + 4);
            }
            
            // Draw control limits (step function)
            if (points[0].ucl != null) {
                ctx.strokeStyle = '#fb923c';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                
                // UCL
                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const x = xScale(i);
                    const y = yScale(points[i].ucl);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // LCL
                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const x = xScale(i);
                    const y = yScale(points[i].lcl);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            // Draw center line (step function)
            if (points[0].cl != null) {
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const x = xScale(i);
                    const y = yScale(points[i].cl);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // Draw value line
            ctx.strokeStyle = '#38bdf8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < points.length; i++) {
                const x = xScale(i);
                const y = yScale(points[i].value);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw phase boundaries
            if (data.phases && data.phases.length > 1) {
                ctx.strokeStyle = '#ffffff';
                ctx.setLineDash([2, 2]);
                ctx.lineWidth = 1;
                for (let i = 1; i < data.phases.length; i++) {
                    const x = xScale(data.phases[i].startIndex);
                    ctx.beginPath();
                    ctx.moveTo(x, padding.top);
                    ctx.lineTo(x, height - padding.bottom);
                    ctx.stroke();
                    
                    // Phase label
                    ctx.fillStyle = '#e2e8f0';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(toRoman(i), x + 30, padding.top + 15);
                }
                // First phase label
                ctx.fillText('I', xScale(0) + 30, padding.top + 15);
                ctx.setLineDash([]);
            }
            
            // X-axis
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // X-axis labels (dates)
            ctx.fillStyle = '#9ca3af';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            const labelEvery = Math.max(1, Math.floor(points.length / 5));
            for (let i = 0; i < points.length; i += labelEvery) {
                const x = xScale(i);
                const date = new Date(points[i].date);
                const label = `${date.getMonth() + 1}/${date.getDate()}`;
                ctx.fillText(label, x, height - padding.bottom + 20);
            }
            
            // Draw data points (with highlighting)
            for (let i = 0; i < points.length; i++) {
                const x = xScale(i);
                const y = yScale(points[i].value);
                const outOfControl = points[i].value > points[i].ucl || points[i].value < points[i].lcl;
                const isHighlighted = (highlightIndex !== null && i === highlightIndex);
                
                // Draw crosshair for highlighted point
                if (isHighlighted) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.setLineDash([2, 2]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, padding.top);
                    ctx.lineTo(x, height - padding.bottom);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw point
                ctx.beginPath();
                ctx.arc(x, y, isHighlighted ? 6 : 3, 0, Math.PI * 2);
                ctx.fillStyle = outOfControl ? '#f87171' : '#38bdf8';
                ctx.fill();
                
                // Draw glow for highlighted point
                if (isHighlighted) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }
        
        function toRoman(num) {
            const vals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
            const syms = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];
            let roman = '';
            for (let i = 0; i < vals.length; i++) {
                while (num >= vals[i]) {
                    roman += syms[i];
                    num -= vals[i];
                }
            }
            return roman;
        }

        async function downloadChartWithHeader(containerId, chartName) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Use html2canvas if available, otherwise create composite canvas
            const compositeCanvas = document.createElement('canvas');
            const ctx = compositeCanvas.getContext('2d');
            
            // Set canvas size to match container
            const rect = container.getBoundingClientRect();
            compositeCanvas.width = rect.width * 2; // 2x for better quality
            compositeCanvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            // Draw background
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, rect.width, rect.height);
            
            // Get elements
            const header = container.querySelector('.chart-header');
            const canvas = container.querySelector('.chart-canvas');
            const legend = container.querySelector('.legend');
            
            // Draw header
            const headerRect = header.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const headerY = headerRect.top - containerRect.top;
            
            // Header background
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, headerY, rect.width, headerRect.height);
            
            // Header text
            const title = header.querySelector('.chart-title').textContent;
            const subtitle = header.querySelector('.chart-subtitle').textContent;
            const stats = Array.from(header.querySelectorAll('.chart-stat'));
            
            ctx.fillStyle = '#e5e7eb';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText(title, 16, headerY + 30);
            
            ctx.fillStyle = '#9ca3af';
            ctx.font = '14px sans-serif';
            ctx.fillText(subtitle, 16, headerY + 50);
            
            // Draw stats on right side
            let statsX = rect.width - 350;
            ctx.font = '12px sans-serif';
            stats.forEach((stat, i) => {
                const label = stat.querySelector('.chart-stat-label').textContent;
                const value = stat.querySelector('.chart-stat-value').textContent;
                
                ctx.fillStyle = '#9ca3af';
                ctx.fillText(label, statsX + (i * 90), headerY + 30);
                
                ctx.fillStyle = '#06b6d4';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText(value, statsX + (i * 90), headerY + 50);
                ctx.font = '12px sans-serif';
            });
            
            // Draw chart canvas
            const canvasRect = canvas.getBoundingClientRect();
            const canvasY = canvasRect.top - containerRect.top;
            ctx.drawImage(canvas, 0, canvasY, canvasRect.width, canvasRect.height);
            
            // Draw legend
            const legendRect = legend.getBoundingClientRect();
            const legendY = legendRect.top - containerRect.top;
            
            ctx.font = '14px sans-serif';
            const legendItems = Array.from(legend.querySelectorAll('.legend-item'));
            let legendX = (rect.width - (legendItems.length * 100)) / 2;
            
            legendItems.forEach((item) => {
                const lineColor = item.querySelector('.legend-line').style.background;
                const text = item.querySelector('span').textContent;
                
                // Draw colored line
                ctx.fillStyle = lineColor;
                ctx.fillRect(legendX, legendY + 8, 30, 3);
                
                // Draw text
                ctx.fillStyle = '#e5e7eb';
                ctx.fillText(text, legendX + 40, legendY + 15);
                
                legendX += 100;
            });
            
            // Add footer with timestamp and metadata
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, rect.height - 30, rect.width, 30);
            
            ctx.fillStyle = '#9ca3af';
            ctx.font = '11px sans-serif';
            const timestamp = new Date().toLocaleString();
            ctx.fillText(`Generated: ${timestamp} | Wheeler's XmR Charts | NPL: 2.66σ`, 16, rect.height - 12);
            
            // Download
            const link = document.createElement('a');
            link.download = `${chartName.replace(/[^a-zA-Z0-9]/g, '_')}.png`;
            link.href = compositeCanvas.toDataURL('image/png');
            link.click();
        }

        function showError(message) {
            document.getElementById('content').innerHTML = `
                <div class="error">
                    <h2 style="margin-bottom: 1rem;">Error</h2>
                    <p>${message}</p>
                </div>
            `;
        }
    </script>
</body>
</html>

