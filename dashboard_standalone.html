<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Southwest Tech Ops Station Health Dashboard</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', sans-serif;
            background: #F7F8FA;
            color: #111B40;
        }
        .header {
            background: #111B40;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.75rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        .header h1 {
            color: #FFFFFF;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .logo {
            height: 80px;
            width: auto;
            object-fit: contain;
        }
        .app-title {
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            line-height: 1.2;
            white-space: nowrap;
        }
        .controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }
        .link-docs {
            background: #FFFFFF;
            color: #111B40;
            border: 1.5px solid #9CA3AF;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 0.875rem;
            text-decoration: none;
        }
        .link-docs:hover {
            background: #F3F4F6;
            border-color: #6B7280;
        }
        button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.875rem;
            letter-spacing: 0.025em;
        }
        .btn-primary {
            background: #304CB2;
            color: white;
            box-shadow: 0 1px 3px rgba(48, 76, 178, 0.2);
        }
        .btn-primary:hover { 
            background: #2844A8;
            box-shadow: 0 4px 12px rgba(48, 76, 178, 0.3);
            transform: translateY(-1px);
        }
        .btn-secondary {
            background: white;
            color: #304CB2;
            border: 1.5px solid #304CB2;
        }
        .btn-secondary:hover { 
            background: #F0F4FF;
            border-color: #2844A8;
        }
        input[type="text"], select {
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1.5px solid #D1D5DB;
            background: white;
            color: #111B40;
            font-weight: 500;
            font-size: 0.875rem;
        }
        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: #304CB2;
            box-shadow: 0 0 0 3px rgba(48, 76, 178, 0.1);
        }
        .main {
            padding: 2rem;
        }
        .station-section {
            margin-bottom: 3rem;
        }
        .station-title {
            color: #111B40;
            font-size: 1.75rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 3px solid #304CB2;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 2rem;
        }
        .chart-container {
            background: white;
            padding: 0;
            border-radius: 0.5rem;
            width: 100%;
            max-width: 100%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.04);
            border: 1px solid #E5E7EB;
        }
        .chart-header {
            background: #FAFBFC;
            margin: 0;
            padding: 1rem 1.25rem;
            border-radius: 0.5rem 0.5rem 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #E5E7EB;
        }
        .chart-title {
            font-size: 1rem;
            font-weight: 700;
            color: #111B40;
            letter-spacing: -0.025em;
        }
        .chart-subtitle {
            font-size: 0.8125rem;
            color: #6B7280;
            margin-top: 0.125rem;
            font-weight: 500;
        }
        .chart-stats {
            display: flex;
            gap: 1.5rem;
            font-size: 0.8125rem;
            color: #111B40;
        }
        .chart-stat {
            display: flex;
            flex-direction: column;
        }
        .chart-stat-label {
            color: #6B7280;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .chart-stat-value {
            font-weight: 700;
            font-size: 1rem;
            color: #111B40;
        }
        .chart-canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
            min-height: 400px;
            max-height: 600px;
            background: #FFFFFF;
            border-radius: 0;
            cursor: crosshair;
        }
        .chart-wrapper {
            position: relative;
        }
        .tooltip {
            position: absolute;
            background: white;
            border: 2px solid #304CB2;
            border-radius: 0.5rem;
            padding: 0.875rem;
            pointer-events: none;
            display: none;
            z-index: 1000;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            min-width: 220px;
        }
        .tooltip-date {
            font-weight: 700;
            color: #111B40;
            margin-bottom: 0.625rem;
            font-size: 0.875rem;
            border-bottom: 2px solid #304CB2;
            padding-bottom: 0.375rem;
        }
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 0.375rem 0;
            font-size: 0.8125rem;
        }
        .measure-group {
            background: #FFFFFF;
            border-radius: 0.75rem;
            padding: 2rem;
            margin-bottom: 2.5rem;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            border: 1px solid #E5E7EB;
        }
        .measure-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #E5E7EB;
        }
        .measure-group-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: #111B40;
        }
        .phase-control {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .phase-control-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #6B7280;
            white-space: nowrap;
        }
        .phase-slider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #E5E7EB;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }
        .phase-slider::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #304CB2;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .phase-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #304CB2;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .phase-value-display {
            font-size: 0.875rem;
            font-weight: 600;
            color: #304CB2;
            min-width: 60px;
            text-align: center;
        }
        .measure-charts {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
        }
        .tooltip-label {
            color: #6B7280;
            margin-right: 1rem;
            font-weight: 600;
        }
        .tooltip-value {
            font-weight: 700;
            color: #111B40;
        }
        .tooltip-value.out-of-control {
            color: #C4122F;
            font-weight: 800;
        }
        .tooltip-value.in-control {
            color: #10B981;
        }
        .loading {
            text-align: center;
            padding: 4rem;
            font-size: 1.25rem;
            color: #304CB2;
            font-weight: 600;
        }
        .error {
            text-align: center;
            padding: 2rem;
            background: #FEF2F2;
            border: 2px solid #FCA5A5;
            border-radius: 0.5rem;
            color: #991B1B;
            font-weight: 600;
        }
        .message {
            text-align: center;
            padding: 2.5rem;
            background: white;
            border-radius: 0.5rem;
            color: #111B40;
            border: 1px solid #E5E7EB;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 1rem 0;
            padding: 0.75rem;
            font-size: 0.8125rem;
            background: #FAFBFC;
            border-radius: 0 0 0.5rem 0.5rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            color: #6B7280;
        }
        .legend-line {
            width: 32px;
            height: 3px;
            border-radius: 2px;
        }
        
        @media (max-width: 1200px) {
            .measure-charts {
                grid-template-columns: 1fr;
            }
        }
        
        @media print {
            .measure-group {
                page-break-inside: avoid;
                page-break-after: always;
            }
            
            .chart-canvas {
                max-height: none;
            }
            
            button {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>
            <img src="images/20251007_0649_Southwest Tech Badge_simple_compose_01k6z814avfefa6hd9mw6753v1.png" alt="Southwest Tech Ops" class="logo">
            <span class="app-title">Station Health Dashboard</span>
        </h1>
        <div class="controls">
            <button class="btn-primary" onclick="loadActualData()" style="font-size: 0.95rem;">📊 Load Test Data</button>
            <input type="file" id="csvFile" accept=".csv" style="display:none" onchange="handleFileUpload(event)">
            <button class="btn-secondary" onclick="document.getElementById('csvFile').click()">📤 Upload CSV</button>
            <input type="text" id="newStation" placeholder="Add Station (e.g., SFO)" style="width: 160px">
            <button class="btn-secondary" onclick="addStation()">Add</button>
            <a class="link-docs" href="SPC_Rules_and_Odds.html" target="_blank" rel="noopener">📘 SPC Rules & Odds</a>
            <select id="stationSelect" onchange="filterStation()">
                <option value="all">All Stations</option>
                <option value="ABQ">ABQ - Albuquerque</option>
                <option value="ALB">ALB - Albany</option>
                <option value="AMA">AMA - Amarillo</option>
                <option value="ATL">ATL - Atlanta</option>
                <option value="AUS">AUS - Austin</option>
                <option value="BDL">BDL - Hartford</option>
                <option value="BHM">BHM - Birmingham</option>
                <option value="BNA">BNA - Nashville</option>
                <option value="BOI">BOI - Boise</option>
                <option value="BOS">BOS - Boston</option>
                <option value="BUF">BUF - Buffalo</option>
                <option value="BUR">BUR - Burbank</option>
                <option value="BWI">BWI - Baltimore</option>
                <option value="CHS">CHS - Charleston</option>
                <option value="CLE">CLE - Cleveland</option>
                <option value="CLT">CLT - Charlotte</option>
                <option value="CMH">CMH - Columbus</option>
                <option value="CRP">CRP - Corpus Christi</option>
                <option value="CUN">CUN - Cancun</option>
                <option value="DAL">DAL - Dallas Love Field</option>
                <option value="DCA">DCA - Washington Reagan</option>
                <option value="DEN">DEN - Denver</option>
                <option value="DSM">DSM - Des Moines</option>
                <option value="DTW">DTW - Detroit</option>
                <option value="ELP">ELP - El Paso</option>
                <option value="FLL">FLL - Fort Lauderdale</option>
                <option value="GRR">GRR - Grand Rapids</option>
                <option value="HOU">HOU - Houston Hobby</option>
                <option value="IAD">IAD - Washington Dulles</option>
                <option value="IAH">IAH - Houston Intercontinental</option>
                <option value="ICT">ICT - Wichita</option>
                <option value="IND">IND - Indianapolis</option>
                <option value="JAX">JAX - Jacksonville</option>
                <option value="LAS">LAS - Las Vegas</option>
                <option value="LAX">LAX - Los Angeles</option>
                <option value="LBB">LBB - Lubbock</option>
                <option value="LGA">LGA - New York LaGuardia</option>
                <option value="LIT">LIT - Little Rock</option>
                <option value="MAF">MAF - Midland</option>
                <option value="MBJ">MBJ - Montego Bay</option>
                <option value="MCI">MCI - Kansas City</option>
                <option value="MCO">MCO - Orlando</option>
                <option value="MDW">MDW - Chicago Midway</option>
                <option value="MEM">MEM - Memphis</option>
                <option value="MEX">MEX - Mexico City</option>
                <option value="MHT">MHT - Manchester</option>
                <option value="MKE">MKE - Milwaukee</option>
                <option value="MSP">MSP - Minneapolis</option>
                <option value="MSY">MSY - New Orleans</option>
                <option value="OAK">OAK - Oakland</option>
                <option value="OKC">OKC - Oklahoma City</option>
                <option value="OMA">OMA - Omaha</option>
                <option value="ONT">ONT - Ontario</option>
                <option value="ORF">ORF - Norfolk</option>
                <option value="PBI">PBI - West Palm Beach</option>
                <option value="PDX">PDX - Portland</option>
                <option value="PHL">PHL - Philadelphia</option>
                <option value="PHX">PHX - Phoenix</option>
                <option value="PIT">PIT - Pittsburgh</option>
                <option value="PNS">PNS - Pensacola</option>
                <option value="PVD">PVD - Providence</option>
                <option value="PVR">PVR - Puerto Vallarta</option>
                <option value="PWM">PWM - Portland, ME</option>
                <option value="RDU">RDU - Raleigh-Durham</option>
                <option value="RNO">RNO - Reno</option>
                <option value="RSW">RSW - Fort Myers</option>
                <option value="SAN">SAN - San Diego</option>
                <option value="SAT">SAT - San Antonio</option>
                <option value="SDF">SDF - Louisville</option>
                <option value="SEA">SEA - Seattle</option>
                <option value="SFO">SFO - San Francisco</option>
                <option value="SJC">SJC - San Jose</option>
                <option value="SJD">SJD - Cabo San Lucas</option>
                <option value="SJU">SJU - San Juan</option>
                <option value="SLC">SLC - Salt Lake City</option>
                <option value="SMF">SMF - Sacramento</option>
                <option value="SNA">SNA - Orange County</option>
                <option value="STL">STL - St. Louis</option>
                <option value="TPA">TPA - Tampa</option>
                <option value="TUL">TUL - Tulsa</option>
                <option value="TUS">TUS - Tucson</option>
            </select>
        </div>
    </div>
    
    <div class="main">
        <div id="content">
            <div class="message">
                <p style="font-size: 1.5rem; margin-bottom: 1rem;">📊 Ready to View SPC Charts</p>
                <p style="font-size: 1.125rem; color: #9ca3af;">Click <strong style="color: #059669;">"Load Test Data"</strong> above to view:</p>
                <ul style="list-style: none; padding: 0; margin-top: 1rem; font-size: 1rem; color: #d1d5db;">
                    <li>✓ Austin (AUS)</li>
                    <li>✓ Dallas Love Field (DAL)</li>
                    <li>✓ Houston Hobby (HOU)</li>
                </ul>
                <p style="margin-top: 1rem; font-size: 0.875rem; color: #6b7280;">Simulated test data • January 2023 to present • 4 maintenance metrics</p>
                <p style="margin-top: 0.5rem; font-size: 0.75rem; color: #6b7280;">Upload supports: timestamp,station,metric_value (filename = measure) OR station,measure,date,value</p>
            </div>
        </div>
    </div>

    <script>
        let allData = null;
        let chartData = null;
        let currentFilter = 'all';
        let phaseSelections = {}; // Track phase selections per measure group

        async function loadActualData() {
            document.getElementById('content').innerHTML = '<div class="loading">Loading Test Data...</div>';
            
            try {
                const response = await fetch('http://localhost:8000/api/load-actual', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    chartData = result.chartData;
                    phaseSelections = {};  // Reset phase selections
                    updateStationSelect(result.stations);
                    renderCharts();
                } else {
                    showError(result.error || 'Failed to load test data');
                }
            } catch (err) {
                showError('Failed to connect to server. Make sure server.py is running.');
            }
        }

        async function loadDemoData() {
            document.getElementById('content').innerHTML = '<div class="loading">Processing Data...</div>';
            
            try {
                const response = await fetch('http://localhost:8000/api/demo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    chartData = result.chartData;
                    phaseSelections = {};  // Reset phase selections
                    updateStationSelect(result.stations);
                    renderCharts();
                } else {
                    showError(result.error || 'Failed to process data');
                }
            } catch (err) {
                showError('Failed to connect to server. Make sure server.py is running.');
            }
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('content').innerHTML = '<div class="loading">Processing ' + file.name + '...</div>';
            
            try {
                const text = await file.text();
                const response = await fetch('http://localhost:8000/api/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        csvData: text,
                        filename: file.name
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    chartData = result.chartData;
                    phaseSelections = {};  // Reset phase selections
                    updateStationSelect(result.stations);
                    renderCharts();
                } else {
                    // Show the actual error message from the server
                    showError(`Upload Failed: ${result.error || 'Unknown error occurred'}`);
                }
            } catch (err) {
                showError('Failed to process CSV file: ' + err.message);
            }
        }

        function updateStationSelect(stations) {
            const select = document.getElementById('stationSelect');
            select.innerHTML = '<option value="all">All Stations</option>';
            stations.forEach(station => {
                const option = document.createElement('option');
                option.value = station;
                option.textContent = station;
                select.appendChild(option);
            });
        }

        function filterStation() {
            currentFilter = document.getElementById('stationSelect').value;
            renderCharts();
        }

        function addStation() {
            const input = document.getElementById('newStation');
            const station = input.value.trim().toUpperCase();
            if (station) {
                const select = document.getElementById('stationSelect');
                const exists = Array.from(select.options).some(opt => opt.value === station);
                if (!exists) {
                    const option = document.createElement('option');
                    option.value = station;
                    option.textContent = station;
                    select.appendChild(option);
                }
                input.value = '';
            }
        }

        function filterToLastNPhases(data, numPhases) {
            /**
             * Filter chart data to show only the last N phases
             * Returns filtered data with adjusted indices
             */
            // Skip filtering for distribution charts (no phases)
            if (data.type === 'distribution') {
                return data;
            }
            
            if (!data.phases || data.phases.length === 0) {
                return data;
            }
            
            // If numPhases is 'all' or >= total phases, return all data
            if (numPhases === 'all' || numPhases >= data.phases.length) {
                return data;
            }
            
            // Get the last N phases
            const phasesToShow = data.phases.slice(-numPhases);
            
            // Find the start index (beginning of the Nth-to-last phase)
            const startIndex = phasesToShow[0].startIndex;
            
            // Filter points to only include those from startIndex onward
            const filteredPoints = data.points.slice(startIndex);
            
            // **FIX: Adjust phase indices to be relative to filtered points**
            const adjustedPhases = phasesToShow.map(phase => ({
                ...phase,
                startIndex: phase.startIndex - startIndex,  // Make relative to filtered array
                endIndex: phase.endIndex - startIndex      // Make relative to filtered array
            }));
            
            // For distribution chart, filter histogram data to match date range
            let filteredHistogram = data.histogram;
            if (data.histogram && filteredPoints.length > 0) {
                const startDate = filteredPoints[0].date;
                const endDate = filteredPoints[filteredPoints.length - 1].date;
                // Filter histogram bins to match the date range (simplified)
                filteredHistogram = data.histogram; // Keep for now, can enhance later
            }
            
            // Create new data object with filtered points and adjusted phases
            return {
                ...data,
                points: filteredPoints,
                phases: adjustedPhases,
                histogram: filteredHistogram,
                originalPhaseCount: data.phases.length,  // Track total phases
                filteredFrom: startIndex
            };
        }

        function renderCharts() {
            if (!chartData) return;
            
            const stations = currentFilter === 'all' 
                ? Object.keys(chartData) 
                : [currentFilter];
            
            let html = '';
            
            stations.forEach(station => {
                if (!chartData[station]) return;
                
                html += `<div class="station-section">`;
                html += `<h2 class="station-title">${station}</h2>`;
                
                const allMeasures = Object.keys(chartData[station]);
                
                // Group measures by base name
                const measureGroups = {};
                allMeasures.forEach(measure => {
                    const baseMeasure = measure
                        .replace(' (Moving Range)', '')
                        .replace(' (Distribution)', '');
                    
                    if (!measureGroups[baseMeasure]) {
                        measureGroups[baseMeasure] = {
                            x: null,
                            mr: null,
                            dist: null,
                            maxPhases: 0
                        };
                    }
                    
                    if (measure.includes('(Distribution)')) {
                        measureGroups[baseMeasure].dist = measure;
                    } else if (measure.includes('(Moving Range)')) {
                        measureGroups[baseMeasure].mr = measure;
                        const phases = chartData[station][measure].phases || [];
                        measureGroups[baseMeasure].maxPhases = Math.max(
                            measureGroups[baseMeasure].maxPhases, 
                            phases.length
                        );
                    } else {
                        measureGroups[baseMeasure].x = measure;
                        const phases = chartData[station][measure].phases || [];
                        measureGroups[baseMeasure].maxPhases = Math.max(
                            measureGroups[baseMeasure].maxPhases, 
                            phases.length
                        );
                    }
                });
                
                // Sort base measures alphabetically
                const sortedBaseMeasures = Object.keys(measureGroups).sort();
                
                // Render each measure group
                sortedBaseMeasures.forEach(baseMeasure => {
                    const group = measureGroups[baseMeasure];
                    const groupId = `${station}-${baseMeasure}`.replace(/[^a-zA-Z0-9]/g, '-');
                    const maxPhases = group.maxPhases;
                    const groupKey = `${station}-${baseMeasure}`;
                    const defaultPhases = phaseSelections[groupKey] || maxPhases;  // Use saved or default to all phases
                    
                    html += `<div class="measure-group" id="group-${groupId}">`;
                    html += `<div class="measure-group-header">`;
                    html += `<div class="measure-group-title">${baseMeasure}</div>`;
                    
                    if (maxPhases > 1) {
                        html += `<div class="phase-control">`;
                        html += `<label class="phase-control-label">Show Phases:</label>`;
                        html += `<input type="range" 
                                   class="phase-slider" 
                                   id="slider-${groupId}"
                                   min="1" 
                                   max="${maxPhases}" 
                                   value="${defaultPhases}"
                                   onchange="updatePhaseZoom('${station}', '${baseMeasure}', this.value)">`;
                        html += `<span class="phase-value-display" id="value-${groupId}">Last ${defaultPhases} of ${maxPhases}</span>`;
                        html += `</div>`;
                    }
                    
                    html += `</div>`;  // End measure-group-header
                    html += `<div class="measure-charts">`;
                    
                    // Render X, mR, and Distribution charts in order
                    [group.x, group.mr, group.dist].forEach(measure => {
                        if (!measure) return;
                        
                        const data = chartData[station][measure];
                        const canvasId = `chart-${station}-${measure}`.replace(/[^a-zA-Z0-9]/g, '-');
                        
                        // Apply phase filter (defaults to all phases)
                        const filteredData = filterToLastNPhases(data, defaultPhases);
                        const points = filteredData.points || [];
                        
                        // Calculate statistics
                        const mean = points.length > 0 ? (points.reduce((sum, p) => sum + p.value, 0) / points.length).toFixed(2) : 'N/A';
                        const ucl = points.length > 0 && points[0].ucl ? points[0].ucl.toFixed(2) : 'N/A';
                        const lcl = points.length > 0 && points[0].lcl ? points[0].lcl.toFixed(2) : 'N/A';
                        const dateRange = points.length > 0 ? `${new Date(points[0].date).toLocaleDateString()} - ${new Date(points[points.length-1].date).toLocaleDateString()}` : '';
                        
                        // Determine chart type and signal status
                        const isXChart = !measure.includes('Moving Range') && !measure.includes('Distribution');
                        const isMRChart = measure.includes('Moving Range');
                        const signalInfo = filteredData.signal_info || {};

                        let headerBadge = '';
                        if (isXChart && signalInfo.x_signal_count > 0) {
                            headerBadge = '<span style="margin-left: 0.5rem; padding: 0.125rem 0.5rem; background: #DBEAFE; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; color: #1E40AF;">🔔 Signaling</span>';
                        } else if (isMRChart && signalInfo.mr_signal_count > 0) {
                            headerBadge = '<span style="margin-left: 0.5rem; padding: 0.125rem 0.5rem; background: #FCE7F3; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; color: #9F1239;">🔔 Signaling</span>';
                        }

                        html += `
                            <div class="chart-container" id="container-${canvasId}" data-station="${station}" data-base-measure="${baseMeasure}" data-measure="${measure}">
                                <div class="chart-header">
                                    <div>
                                        <div class="chart-title">${measure}${headerBadge}</div>
                                        <div class="chart-subtitle">${station} • ${dateRange}</div>
                                    </div>
                                    <div class="chart-stats">
                                        <div class="chart-stat">
                                            <span class="chart-stat-label">Mean</span>
                                            <span class="chart-stat-value">${mean}</span>
                                        </div>
                                        <div class="chart-stat">
                                            <span class="chart-stat-label">UCL</span>
                                            <span class="chart-stat-value">${ucl}</span>
                                        </div>
                                        <div class="chart-stat">
                                            <span class="chart-stat-label">LCL</span>
                                            <span class="chart-stat-value">${lcl}</span>
                                        </div>
                                        <button onclick="downloadChartWithHeader('container-${canvasId}', '${station}_${measure}')" 
                                                style="padding: 0.4rem 0.75rem; background: #4f46e5; color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; margin-left: 0.5rem;">
                                            💾 Save PNG
                                        </button>
                                    </div>
                                </div>
                                <div class="chart-wrapper">
                                    <canvas id="${canvasId}" class="chart-canvas"></canvas>
                                    <div id="tooltip-${canvasId}" class="tooltip"></div>
                                </div>
                                <div class="legend">
                                    <div class="legend-item">
                                        <div class="legend-line" style="background: #304CB2;"></div>
                                        <span>Value</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-line" style="background: #10B981;"></div>
                                        <span>CL</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-line" style="background: #F87171;"></div>
                                        <span>UCL/LCL</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `</div>`;  // End measure-charts
                    html += `</div>`;  // End measure-group
                });
                
                html += `</div>`;  // End station-section
            });
            
            document.getElementById('content').innerHTML = html;
            
            // Draw all charts with default filter applied
            stations.forEach(station => {
                if (!chartData[station]) return;
                
                const allMeasures = Object.keys(chartData[station]);
                allMeasures.forEach(measure => {
                    const data = chartData[station][measure];
                    const baseMeasure = measure
                        .replace(' (Moving Range)', '')
                        .replace(' (Distribution)', '');
                    const maxPhases = data.phases ? data.phases.length : 0;
                    const groupKey = `${station}-${baseMeasure}`;
                    const defaultPhases = phaseSelections[groupKey] || maxPhases;  // Use saved or default to all phases
                    
                    const filteredData = filterToLastNPhases(data, defaultPhases);
                    const canvasId = `chart-${station}-${measure}`.replace(/[^a-zA-Z0-9]/g, '-');
                    const canvas = document.getElementById(canvasId);
                    const tooltip = document.getElementById(`tooltip-${canvasId}`);
                    
                    if (canvas && tooltip) {
                        if (measure.includes('(Distribution)')) {
                            const xData = chartData[station][baseMeasure];
                            const filteredX = filterToLastNPhases(xData, defaultPhases);
                            const values = (filteredX.points || []).map(p => p.value);
                            const hist = buildHistogram(values);
                            drawHistogram(canvas, hist);
                        } else {
                            drawChart(canvas, filteredData);
                            setupInteractivity(canvas, tooltip, filteredData);
                        }
                    }
                });
            });
        }

        function updatePhaseZoom(station, baseMeasure, numPhases) {
            /**
             * Update charts for a specific measure group when slider changes
             */
            numPhases = parseInt(numPhases);
            const groupId = `${station}-${baseMeasure}`.replace(/[^a-zA-Z0-9]/g, '-');
            const groupKey = `${station}-${baseMeasure}`;
            phaseSelections[groupKey] = numPhases;  // Save state
            
            // Update display text
            const valueDisplay = document.getElementById(`value-${groupId}`);
            const slider = document.getElementById(`slider-${groupId}`);
            const maxPhases = parseInt(slider.max);
            
            if (valueDisplay) {
                valueDisplay.textContent = `Last ${numPhases} of ${maxPhases}`;
            }
            
            // Get all chart containers for this measure group
            const containers = document.querySelectorAll(
                `[data-station="${station}"][data-base-measure="${baseMeasure}"]`
            );
            
            containers.forEach(container => {
                const measure = container.getAttribute('data-measure');
                const data = chartData[station][measure];
                
                // Apply filter
                const filteredData = filterToLastNPhases(data, numPhases);
                
                // Update chart statistics in header
                const points = filteredData.points || [];
                if (points.length > 0) {
                    const mean = (points.reduce((sum, p) => sum + p.value, 0) / points.length).toFixed(2);
                    const dateRange = `${new Date(points[0].date).toLocaleDateString()} - ${new Date(points[points.length-1].date).toLocaleDateString()}`;
                    
                    // Update subtitle with new date range
                    const subtitle = container.querySelector('.chart-subtitle');
                    if (subtitle) {
                        subtitle.textContent = `${station} • ${dateRange}`;
                    }
                    
                    // Update mean stat
                    const meanValue = container.querySelector('.chart-stat:nth-child(1) .chart-stat-value');
                    if (meanValue) {
                        meanValue.textContent = mean;
                    }
                }
                
                // Redraw chart
                const canvasId = `chart-${station}-${measure}`.replace(/[^a-zA-Z0-9]/g, '-');
                const canvas = document.getElementById(canvasId);
                const tooltip = document.getElementById(`tooltip-${canvasId}`);
                
                if (canvas && tooltip) {
                    if (measure.includes('(Distribution)')) {
                        const xData = chartData[station][baseMeasure];
                        const filteredX = filterToLastNPhases(xData, numPhases);
                        const values = (filteredX.points || []).map(p => p.value);
                        const hist = buildHistogram(values);
                        drawHistogram(canvas, hist);
                    } else {
                        drawChart(canvas, filteredData);
                        setupInteractivity(canvas, tooltip, filteredData);
                    }
                }
            });
        }

        function setupInteractivity(canvas, tooltip, data) {
            const rect = canvas.getBoundingClientRect();
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const plotWidth = rect.width - padding.left - padding.right;
            
            canvas.addEventListener('mousemove', (e) => {
                const mouseX = e.offsetX;
                const mouseY = e.offsetY;
                
                // Check if mouse is in plot area
                if (mouseX < padding.left || mouseX > rect.width - padding.right ||
                    mouseY < padding.top || mouseY > rect.height - padding.bottom) {
                    tooltip.style.display = 'none';
                    return;
                }
                
                // Find nearest data point
                const points = data.points;
                const xScale = plotWidth / (points.length - 1);
                const index = Math.round((mouseX - padding.left) / xScale);
                
                if (index >= 0 && index < points.length) {
                    const point = points[index];
                    const outOfControl = point.value > point.ucl || point.value < point.lcl;
                    const dateStr = new Date(point.date).toLocaleDateString('en-US', { 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric' 
                    });
                    
                    // Calculate odds display - "1 in X" format
                    const odds = point.odds || 1;
                    const oddsText = odds >= 10000 ? '1 in 10,000+' : `1 in ${Math.round(odds)}`;

                    // Determine signal status for this specific point
                    let signalBadge = '';
                    if (point.both_signaling) {
                        signalBadge = '<div style="margin-top: 0.5rem; padding: 0.25rem 0.5rem; background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; color: #92400E;">⚠️ Both X & mR Signaling</div>';
                    } else if (point.x_only_signal) {
                        signalBadge = '<div style="margin-top: 0.5rem; padding: 0.25rem 0.5rem; background: #DBEAFE; border: 1px solid #3B82F6; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; color: #1E40AF;">📊 X Chart Signal</div>';
                    } else if (point.mr_only_signal) {
                        signalBadge = '<div style="margin-top: 0.5rem; padding: 0.25rem 0.5rem; background: #FCE7F3; border: 1px solid #EC4899; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; color: #9F1239;">📈 mR Chart Signal</div>';
                    }
                    
                    tooltip.innerHTML = `
                        <div class="tooltip-date">${dateStr}</div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Value:</span>
                            <span class="tooltip-value ${outOfControl ? 'out-of-control' : 'in-control'}">${point.value.toFixed(2)}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">UCL:</span>
                            <span class="tooltip-value">${point.ucl.toFixed(2)}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">CL:</span>
                            <span class="tooltip-value">${point.cl.toFixed(2)}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">LCL:</span>
                            <span class="tooltip-value">${point.lcl.toFixed(2)}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Odds:</span>
                            <span class="tooltip-value" style="color: #7C3AED; font-weight: 700;">${oddsText}</span>
                        </div>
                        ${signalBadge}
                        ${outOfControl ? '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #374151; color: #f87171; font-size: 0.75rem; font-weight: 700;">⚠️ OUT OF CONTROL</div>' : ''}
                    `;
                    
                    // Position tooltip to avoid obscuring the data point
                    // Show to left/right based on mouse position in chart
                    const tooltipX = e.offsetX > rect.width / 2 ? 
                        Math.max(e.offsetX - 260, 10) :  // Left side if mouse is on right
                        Math.min(e.offsetX + 15, rect.width - 250);  // Right side if mouse is on left

                    // Show above/below based on mouse position in chart
                    const tooltipY = e.offsetY > rect.height / 2 ? 
                        Math.max(e.offsetY - 140, 10) :  // Above if mouse is in lower half
                        Math.min(e.offsetY + 15, rect.height - 130);  // Below if mouse is in upper half
                    
                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                    tooltip.style.display = 'block';
                    
                    // Highlight point
                    drawChart(canvas, data, index);
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
                drawChart(canvas, data);
            });
        }
        
        function computeStats(values) {
            const n = values.length || 1;
            const mean = values.reduce((s, v) => s + v, 0) / n;
            const variance = values.reduce((s, v) => s + (v - mean) ** 2, 0) / n;
            return { mean: +mean.toFixed(2), stdDev: +Math.sqrt(variance).toFixed(2) };
        }

        function buildHistogram(values) {
            if (!values || values.length === 0) {
                return { bins: [], frequencies: [], normal_curve: [], mean: 0, std_dev: 0 };
            }
            const sorted = [...values].sort((a, b) => a - b);
            const n = sorted.length;
            const q1 = sorted[Math.floor(0.25 * (n - 1))];
            const q3 = sorted[Math.floor(0.75 * (n - 1))];
            const iqr = Math.max(q3 - q1, 1e-9);
            const range = Math.max(sorted[n - 1] - sorted[0], 1e-9);
            const fdWidth = (2 * iqr) / Math.cbrt(n);
            const binWidth = Math.max(fdWidth, range / 30);
            const binCount = Math.max(6, Math.min(30, Math.ceil(range / binWidth)));
            const min = sorted[0], max = sorted[n - 1];
            const width = (max - min) / binCount || 1;
            const bins = Array.from({ length: binCount }, (_, i) => min + i * width);
            const frequencies = new Array(binCount).fill(0);
            for (const v of values) {
                const idx = Math.min(Math.floor((v - min) / width), binCount - 1);
                frequencies[idx] += 1;
            }
            const { mean, stdDev } = computeStats(values);
            const normal_curve = frequencies.map((_, i) => {
                const c = min + (i + 0.5) * width;
                const z = (c - mean) / (stdDev || 1);
                return Math.exp(-0.5 * z * z);
            });
            return { bins, frequencies, normal_curve, mean: mean.toFixed(2), std_dev: stdDev.toFixed(2) };
        }

        function drawHistogram(canvas, histogramData) {
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;
            
            const bins = histogramData.bins || [];
            const frequencies = histogramData.frequencies || [];
            const normalCurve = histogramData.normal_curve || [];
            
            if (bins.length === 0) return;
            
            const maxFreq = Math.max(...frequencies, ...normalCurve);
            const barWidth = plotWidth / bins.length;
            
            // Clear canvas
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, width, height);
            
            // Draw bars
            ctx.fillStyle = '#3B82F6';
            frequencies.forEach((freq, i) => {
                const barHeight = (freq / maxFreq) * plotHeight;
                const x = padding.left + i * barWidth;
                const y = padding.top + plotHeight - barHeight;
                ctx.fillRect(x, y, barWidth * 0.9, barHeight);
            });
            
            // Draw normal curve overlay
            ctx.strokeStyle = '#EF4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            normalCurve.forEach((value, i) => {
                const x = padding.left + (i + 0.5) * barWidth;
                const y = padding.top + plotHeight - (value / maxFreq) * plotHeight;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Draw axes
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + plotHeight);
            ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
            ctx.stroke();
            
            // Add labels
            ctx.fillStyle = '#374151';
            ctx.font = '12px Inter, system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Mean: ${histogramData.mean}, SD: ${histogramData.std_dev}`, width / 2, height - 10);
        }

        function drawChart(canvas, data, highlightIndex = null) {
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;
            const padding = { top: 20, right: 20, bottom: 40, left: 60 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;
            
            const points = data.points;
            if (!points || points.length === 0) return;
            
            // Get value range
            const values = points.map(p => p.value);
            const ucls = points.map(p => p.ucl).filter(v => v != null);
            const lcls = points.map(p => p.lcl).filter(v => v != null);
            const allValues = [...values, ...ucls, ...lcls];
            const minValue = Math.min(...allValues) * 0.95;
            const maxValue = Math.max(...allValues) * 1.05;
            
            // Helper functions
            const xScale = (index) => padding.left + (index / (points.length - 1)) * plotWidth;
            const yScale = (value) => padding.top + plotHeight - ((value - minValue) / (maxValue - minValue)) * plotHeight;
            
            // Clear canvas
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid lines
            ctx.strokeStyle = '#E5E7EB';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (i / 5) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
                
                // Y-axis labels
                const value = maxValue - (i / 5) * (maxValue - minValue);
                ctx.fillStyle = '#6B7280';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(1), padding.left - 10, y + 4);
            }
            
            // Draw control limits (step function)
            if (points[0].ucl != null) {
                ctx.strokeStyle = '#F87171';
                ctx.setLineDash([4, 4]);
                ctx.lineWidth = 2;
                
                // UCL
                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const x = xScale(i);
                    const y = yScale(points[i].ucl);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                // LCL
                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const x = xScale(i);
                    const y = yScale(points[i].lcl);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            // Draw center line (step function)
            if (points[0].cl != null) {
                ctx.strokeStyle = '#10B981';  // Green color
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    const x = xScale(i);
                    const y = yScale(points[i].cl);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            // Draw value line
            ctx.strokeStyle = '#304CB2';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            for (let i = 0; i < points.length; i++) {
                const x = xScale(i);
                const y = yScale(points[i].value);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw phase boundaries
            if (data.phases && data.phases.length > 1) {
                ctx.strokeStyle = '#9CA3AF';
                ctx.setLineDash([3, 3]);
                ctx.lineWidth = 1.5;
                for (let i = 1; i < data.phases.length; i++) {
                    const x = xScale(data.phases[i].startIndex);
                    ctx.beginPath();
                    ctx.moveTo(x, padding.top);
                    ctx.lineTo(x, height - padding.bottom);
                    ctx.stroke();
                    
                    // Phase label
                    ctx.fillStyle = '#6B7280';
                    ctx.font = '600 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(toRoman(i), x + 30, padding.top + 15);
                }
                // First phase label
                ctx.fillText('I', xScale(0) + 30, padding.top + 15);
                ctx.setLineDash([]);
            }
            
            // X-axis
            ctx.strokeStyle = '#D1D5DB';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();
            
            // X-axis labels (dates)
            ctx.fillStyle = '#6B7280';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            const labelEvery = Math.max(1, Math.floor(points.length / 5));
            for (let i = 0; i < points.length; i += labelEvery) {
                const x = xScale(i);
                const date = new Date(points[i].date);
                const label = `${date.getMonth() + 1}/${date.getDate()}`;
                ctx.fillText(label, x, height - padding.bottom + 20);
            }
            
            // Draw data points (with highlighting)
            for (let i = 0; i < points.length; i++) {
                const x = xScale(i);
                const y = yScale(points[i].value);
                const outOfControl = points[i].value > points[i].ucl || points[i].value < points[i].lcl;
                const isHighlighted = (highlightIndex !== null && i === highlightIndex);
                
                // Draw crosshair for highlighted point
                if (isHighlighted) {
                    ctx.strokeStyle = '#D1D5DB';
                    ctx.setLineDash([2, 2]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, padding.top);
                    ctx.lineTo(x, height - padding.bottom);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw point
                ctx.beginPath();
                ctx.arc(x, y, isHighlighted ? 7 : 4, 0, Math.PI * 2);
                ctx.fillStyle = outOfControl ? '#C4122F' : '#304CB2';
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Draw glow for highlighted point
                if (isHighlighted) {
                    ctx.beginPath();
                    ctx.arc(x, y, 11, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(48, 76, 178, 0.3)';
                    ctx.lineWidth = 5;
                    ctx.stroke();
                }
            }
        }
        
        function toRoman(num) {
            const vals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
            const syms = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];
            let roman = '';
            for (let i = 0; i < vals.length; i++) {
                while (num >= vals[i]) {
                    roman += syms[i];
                    num -= vals[i];
                }
            }
            return roman;
        }

        async function downloadChartWithHeader(containerId, chartName) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Use html2canvas if available, otherwise create composite canvas
            const compositeCanvas = document.createElement('canvas');
            const ctx = compositeCanvas.getContext('2d');
            
            // Set canvas size to match container
            const rect = container.getBoundingClientRect();
            compositeCanvas.width = rect.width * 2; // 2x for better quality
            compositeCanvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            // Draw background
            ctx.fillStyle = '#1f2937';
            ctx.fillRect(0, 0, rect.width, rect.height);
            
            // Get elements
            const header = container.querySelector('.chart-header');
            const canvas = container.querySelector('.chart-canvas');
            const legend = container.querySelector('.legend');
            
            // Draw header
            const headerRect = header.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const headerY = headerRect.top - containerRect.top;
            
            // Header background
            ctx.fillStyle = '#374151';
            ctx.fillRect(0, headerY, rect.width, headerRect.height);
            
            // Header text
            const title = header.querySelector('.chart-title').textContent;
            const subtitle = header.querySelector('.chart-subtitle').textContent;
            const stats = Array.from(header.querySelectorAll('.chart-stat'));
            
            ctx.fillStyle = '#e5e7eb';
            ctx.font = 'bold 18px sans-serif';
            ctx.fillText(title, 16, headerY + 30);
            
            ctx.fillStyle = '#9ca3af';
            ctx.font = '14px sans-serif';
            ctx.fillText(subtitle, 16, headerY + 50);
            
            // Draw stats on right side
            let statsX = rect.width - 350;
            ctx.font = '12px sans-serif';
            stats.forEach((stat, i) => {
                const label = stat.querySelector('.chart-stat-label').textContent;
                const value = stat.querySelector('.chart-stat-value').textContent;
                
                ctx.fillStyle = '#9ca3af';
                ctx.fillText(label, statsX + (i * 90), headerY + 30);
                
                ctx.fillStyle = '#06b6d4';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText(value, statsX + (i * 90), headerY + 50);
                ctx.font = '12px sans-serif';
            });
            
            // Draw chart canvas
            const canvasRect = canvas.getBoundingClientRect();
            const canvasY = canvasRect.top - containerRect.top;
            ctx.drawImage(canvas, 0, canvasY, canvasRect.width, canvasRect.height);
            
            // Draw legend
            const legendRect = legend.getBoundingClientRect();
            const legendY = legendRect.top - containerRect.top;
            
            ctx.font = '14px sans-serif';
            const legendItems = Array.from(legend.querySelectorAll('.legend-item'));
            let legendX = (rect.width - (legendItems.length * 100)) / 2;
            
            legendItems.forEach((item) => {
                const lineColor = item.querySelector('.legend-line').style.background;
                const text = item.querySelector('span').textContent;
                
                // Draw colored line
                ctx.fillStyle = lineColor;
                ctx.fillRect(legendX, legendY + 8, 30, 3);
                
                // Draw text
                ctx.fillStyle = '#e5e7eb';
                ctx.fillText(text, legendX + 40, legendY + 15);
                
                legendX += 100;
            });
            
            // Footer removed per stakeholder request
            
            // Download
            const link = document.createElement('a');
            link.download = `${chartName.replace(/[^a-zA-Z0-9]/g, '_')}.png`;
            link.href = compositeCanvas.toDataURL('image/png');
            link.click();
        }

        function showError(message) {
            document.getElementById('content').innerHTML = `
                <div class="error">
                    <h2 style="margin-bottom: 1rem;">Error</h2>
                    <p>${message}</p>
                </div>
            `;
        }
    </script>
</body>
</html>

